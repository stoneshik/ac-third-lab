- Стрельбицкий Илья Павлович, P33101
- `lisp | cisc | harv | hw | instr | binary | stream | mem | cstr | prob1 | [4]char`
- Вариант с усложнением
## AbobaLisp - Язык программирования
### Синтаксис
#### Формальное описание
```
<program> ::= {(<expression>)}
<expression> ::= <can_nested_exp> | <cannot_nested_exp>
<can_nested_exp> ::= 
              <print_number_exp> |
              <print_exp> |
              "(" "read" " " <name_var> " " <number> ")" |
              "(" <binary_operand> " " <can_nested> " " <can_nested> ")" |
              "(" <ternary_operand> " " <can_nested> " " <can_nested> " " <can_nested> ")" |
              "(" "set" " " <name_var> " " <can_nested> ")"
              "(" "call" " " <name_function> " " <args> ")"
              "(" "iter" " " <name_var> " " <number> " " <can_nested_exp> ")"
<cannot_nested_exp> ::= <function_declaration> | <var_declaration>
<can_nested> ::= <atomic> | <can_nested_exp>
<atomic> ::= <number> | <string> | <name_var>
<binary_operand> ::= "+" | "-" | "*" | "/"
<ternary_operand> ::= "if"
<print_number_exp> ::= "(" "print_number" " " <number> ")" | "(" "print_number" " " <name_var> " " <number> ")"
<print_exp> ::= "(" "print" " " <string> ")" | "(" "print" " " <name_var> " " <number> ")"
<function_declaration> ::= "(" "aboba" " " <name_function> " " <params> " " <can_nested_exp> ")"
<var_declaration> ::= "(" "var" " " <name_var> " " <atomic> ")"
<keyword> ::= "print_number" | "print" | "read" | "+" | "-" | "*" | "/" | "if" | "aboba" | "var" | "set" | "call" | "iter"
<params> ::= "(" {<name_var>} ")"
<args> ::= "(" {<atomic>} ")"
<name_var> ::= "[a-zA-Z_]+"
<name_function> ::= "[a-zA-Z_]+"
<number> ::= "-?\d+"
<string> ::= "".*""
```
#### var - объявление переменной
- 1 аргумент - название переменной.
- 2 аргумент - выражение, инициализирующее переменную.
- Пример объявления переменной: `(var first 0)`
- Выражение не может быть вложенным, поэтому ничего не возвращает.
#### set - присвоение значения переменной
- 1 аргумент - название переменной.
- 2 аргумент - выражение, значение которого присваивается переменной, нельзя присвоить строковое значение.
- Пример присвоения значения переменной: `(set first 3)`
- Выражение возвращает значение переменной.
#### if - условный оператор
- 1 аргумент - выражение-условие.
- 2 аргумент - выражение, которое выполняется, если результат выражения условия равен нулю.
- 3 аргумент - выражение, которое выполняется, если результат выражения условия не равен нулю, либо строка.
- Пример условного оператора: `(if (- a (* 2 (/ a 2))) (print ("a is even")) (print ("a is odd")))`
- Возвращает значение аргумента 2, если результат выражения равен нулю. Возвращает значение аргумента 3, если не равен нулю.
#### iter - оператор цикла
- 1 аргумент - название переменной-итератора, переменная должна быть проинициализирована до этого.
- 2 аргумент - максимальное значение переменной-итератора. Когда значение переменной-итератора становится равным этому числу цикл завершается.
- 3 аргумент - основное выражение - тело цикла, после выполнения тела цикла значение переменной-итератора увеличивается на 1.
- Пример цикла: `(iter i 50 (print i 10))`
- Выражение возвращает последнее значение тела цикла.
#### aboba - определение функции
- 1 аргумент - название функции.
- 2 аргумент - аргументы функции в формате (имя_переменной_1 имя_переменной_2 ... имя_переменной_n).
- 3 аргумент - тело функции (выражение).
- Пример определения функции: `(aboba sum (a b) (+ a b))`
- Выражение не может быть вложенным, поэтому ничего не возвращает.
#### call - вызов функции
- 1 аргумент - название функции.
- 2 аргумент - аргументы функции в формате (аргумент_функции_1 аргумент_функции_2 ... аргумент_функции_n).
- Пример вызова функции: `(call sum (2 8))`
- Выражение возвращает результат работы функции.
#### Математические операторы
- `(+ a 5)` - сложение.
- `(- b 10)` - вычитание.
- `(* 4 5)` - умножение.
- `(/ a b)` - целочисленное деление.
#### Ввод/вывод
- `(print_number 1)` - печать числа (всегда возвращает 0)
- `(print "string for printing")` - печать строки (всегда возвращает 0).
- `(read name_var 20)` - чтение строки в переменную, 2-й аргумент число, 
которое равно значению количества байт выделяемых в куче, 
для того чтобы поместить считываемую строку в кучу (всегда возвращает 0).
#### Переменные
Все переменные объявляются при помощи ключевого слова var.<br>
Типизация динамическая.<br>
Область видимости всех переменных и функций глобальная.<br>
Переменные и функции нельзя назвать именами объявленных ранее переменных или функций.<br>
Выражения объявления переменных и функций не могут быть вложенными.
### Семантика
#### Стратегия вычисления
Аппликативный порядок вычислений, то есть вычисления выполняются слева направо и изнутри наружу.
- Объявления переменных должны быть расположены последовательно в начале программы.
- Объявления функций должны быть расположены последовательно после объявления переменных.
- Все числа положительные.
- Каждое выражение выполняется только после выполнения внутренних элементов.
- Передача аргументов в вызванную функцию только по значению для чисел и указателю для строк.
- Если в качестве аргумента передана строка, то аргументом является указатель на начало этой строки.
- Строки поддерживают специальные символы `\n` - перенос строки, `\t` - табуляция, `r` - возврат каретки.

## Организация памяти
Память разделена на память инструкций и память данных.
### Память инструкций
![image](./img/memory_instruction.png)
1. В памяти 4096 ячеек, адрес ячейки составляет 12 бит.
2. Размер слова составляет 2 байта (16 бит).
3. Последовательное размещение машинных слов, без выравнивания.
### Память данных
![image](./img/memory_data.png)
1. В памяти 4096 ячеек, адрес ячейки составляет 12 бит.
2. Размер машинного слова составляет 4 байта (32 бит).
3. Именованная память - хранит переменные в глобальной области видимости (числа и указатели на строки).
4. 1-я ячейка в памяти - порт ввода, запись не дает никакого эффекта.
5. 2-я ячейка в памяти - порт вывода, чтение всегда возвращает ноль.
6. 3-я ячейка в памяти - хранит начальное значение для Heap Counter.
7. Куча - хранит в себе тела строк и числовые константы.
8. Стек - хранит результаты выражений, аргументы переданные в функции и адреса возврата для функций.
9. Последовательное размещение машинных слов, без выравнивания.
### Регистры
1. Есть 4 регистра общего назначения (R0, R1, R2, R3), размер каждого по 4 байта (32 бит).
2. Program Counter (PC) - счетчик команд, размер 12 бит - значение по умолчанию `0x000`.
3. Address Register (AR) - регистр адреса операнда, размер 12 бит - значение по умолчанию `0x000`.
4. Heap Counter (HC) - счетчик слов записанных в кучу, хранит адрес свободной ячейки следующей 
за последним записанным словом, размер 12 бит - значение по умолчанию `0x0FF`. 
Размер кучи полностью определяется на этапе трансляции в машинный код, по этой причине в рантайме, значение не меняется.
Используется для того, чтобы Control Unit проверял, то что добавляемое значение на стек не заденет кучу.
5. Stack Pointer (SP) - указатель стека, размер 12 бит - значение по умолчанию `0xFFF`.
6. Stack Buffer (SB) - буфер для значения стека увеличенного на значение смещения, размер 12 бит, 
значение по умолчанию `0x000`. Используется при косвенной относительной со смещением от (SP) на память адресации операнда.
7. Instruction Buffer (IB) - буфер, который хранит машинное слово, содержащее номер инструкции, размер 2 байта (16 бит),
значение по умолчанию `0x0000`.
8. Second Operand Buffer (SOB) - буфер, который хранит второй операнд инструкции, загруженный из памяти, 
размер 4 байта (32 бит), значение по умолчанию `0x0000 0000`. <br>
Регистр R0 предназначается для сохранения результата инструкции машинного кода, 
большая часть всех операций совершается с этим регистром.<br>
Результат, который возвращает выражение, добавляется на стек. <br>
Регистр R1 зарезервирован для выгрузки значения со стека, если при этом само выгружаемое значение не нужно 
и для других операций в качестве буфера.<br>
Регистр R2 предназначается для обхода строки в машинном коде, значение указателя помещается в регистр R2,
после чего последовательно инкрементируется.<br>
Регистр R3 предназначается для посимвольного чтения из буфера ввода, и посимвольной записи в буфер вывода.<br>
В отдельных алгоритмах назначение регистров может меняться, но в целом остается выше описанным.
### Особенности
Все данные в памяти хранятся в порядке big endian.<br>
Основной литерал для работы - `number`. Представляет собой беззнаковое целое число, занимает 4 байта (32 бита).<br>
`string` - это совокупность символов закодированных в ASCII, каждый символ занимает 1 байт (8 бит). 
- В одной ячейке памяти хранится до 4 символов. 
- Концом строки является символ `'\0'` (строки нультерминированные).
- Все значения строк хранятся в куче, в переменных хранится только указатель на начало строки. 
- Каждая новая строка пишется в новой ячейке памяти. 
- Так как порядок хранения big endian, то первый символ строки начинается с правой части ячейки памяти 
и дальнейшие символы записываются левее.
- При чтении из буфера ввода символ записывается в старший байт машинного слова регистра, 
поэтому после того как прочитан символ нужно выполнить `srb`. 
Когда в регистр записано 4 символа, то нужно перейти для записи в другое машинное слово.
- При записи в буфер вывода символ записывается из младшего байта машинного слова регистра, 
поэтому после того как символ записан, нужно выполнить `srb`. 
Когда из регистра записано 4 символа, то в регистр нужно загрузить следующее значение из кучи.
- Для того чтобы напечатать число, которое является значением переменной, 
необходимо привести это число к строковому значению. 
Поскольку максимальное число может состоять из 10 цифр, то для записи в куче выделяется буфер в 3 машинных слова, 
после чего запись в буфер осуществляется с конца. Так как число не всегда занимает, все 3 машинных слова, то начало 
получаемой строки может содержать нулевые значения, их алгоритм вывода пропускает.
### Ответы на вопросы
1. В каких случаях литерал будет использован при помощи непосредственной адресации? - 
**Непосредственная адресация отсутствует, поддерживается только прямая абсолютная, прямая косвенная адресации, 
относительная косвенная к (SP) и прямая абсолютная на регистры общего назначения.**
2. В каких случаях литерал будет сохранён в статическую память? -
**Все константные значения помещаются в кучу, во время выполнения литерал может быть выгружен из регистра 
в память при помощи команды `store`.**
3. Как будут размещены литералы, сохранённые в статическую память, друг относительно друга?
**Друг за другом, без выравнивания.**
4. Как будет размещаться в память литерал, требующий для хранения несколько машинных слов?
**Такие литералы это строки, способ их хранения описывался ранее**
5. В каких случаях переменная будет отображена на регистр?
**Случаи когда переменная отображаются на регистр и на какой именно регистр были описаны ранее.**
6. Как будет разрешаться ситуация, если регистров недостаточно для отображения всех переменных?
**Использование регистров прописано так, что их всегда должно хватать,
при этом все переменные и константы хранятся в статической памяти.**
7. В каких случаях переменная будет отображена на статическую память?
**Все переменные при инициализации отображаются на статическую память, при этом имеют глобальную область видимости.**
8. В каких случаях переменная будет отображена на стек?
**Значение переменной может быть отображено на стек, если переменная была передана в качестве аргумента в функцию, 
также результат выражения отображается на стек (если выражение не является вызовом функции).**

## Система команд
### Набор инструкций
1. Машинное слово - 2 байта (16 бит).
2. Так как процессор имеет архитектуру CISC, то инструкции имеют переменную длину - в 1, 2 и 3 машинных слова.
3. 1-е машинное слово всегда содержит номер инструкции, 2-е и 3-е - аргументы команды.
4. Инструкции могут иметь от 0 до 2 аргументов:
   - 0 аргументов - занимает 1 машинное слово.
   - 1 аргумент - занимает 2 машинных слова.
     - 1-й аргумент - операнд (значение из регистра), 2-е машинное слово.
   - 2 аргумента (для остальных команд) - занимает 3 машинных слова.
     - 1-й аргумент - 2-й операнд (значение из памяти), 2-е машинное слово.
     - 2-й аргумент - 1-й операнд (значение из регистра), 3-е машинное слово.
5. Организация 1-го машинного слова команды (нумерация битов справа налево):
   - Состоит из 2 байт (16 бит).
   - Биты [15; 8] - номер инструкции - занимает 1 байт (8 бит).
   - Биты [7; 0] - зарезервированное место - занимает 1 байт (8 бит)
6. Структура аргумента команды (нумерация битов справа налево):
   - Состоит из 2 байт (16 бит).
   - Биты [15, 12] - указание адресации команды - занимает 4 бита.
   - Биты [11, 0] - адрес, если адресация на память; номер регистра общего назначения, если адресация на регистр 
(`0x000` если это R0, ..., `0x003` если это R3) - занимает 12 бит.
7. Указание адресации операнда занимает 4 бита:
   - Прямая абсолютная на память `0xA`.
   - Прямая косвенная на память `0xB`.
   - Косвенная относительная со смещением от (SP) на память `0xC`.
   - Прямая абсолютная на регистр `0xD`.
8. Набор инструкций:
   - `0x00` - `nop` - ничего не делает (0 аргументов).
   - `0x10` - `halt` - завершить выполнение (0 аргументов).
   - `0x20` - `char` - младший байт слова трактуется как число и преобразуется в символ ascii, после чего записывается
в младший байт, остальные байты обнуляются (1 аргумент).
   - `0x21` - `inc` - увеличивает значение на 1 (1 аргумент).
   - `0x22` - `dec` - уменьшает значение на 1 (1 аргумент).
   - `0x23` - `add` - сложение (2 аргумента).
   - `0x24` - `sub` - вычитание (2 аргумента).
   - `0x25` - `mul` - умножение (2 аргумента).
   - `0x26` - `div` - целочисленное деление (2 аргумента).
   - `0x27` - `slb` - shift left byte, сдвиг влево на 1 байт (1 аргумент).
   - `0x28` - `srb` - shift right byte, сдвиг вправо на 1 байт (1 аргумент).
   - `0x29` - `mod` - остаток от деления (2 аргумента).
   - `0x30` - `and` - побитовая конъюнкция (2 аргумента).
   - `0x31` - `or` - побитовая дизъюнкция (2 аргумента).
   - `0x40` - `load` - загрузка значения из памяти в регистр (2 аргумента).
   - `0x41` - `store` - выгрузка значения из регистра в память (2 аргумента).
   - `0x50` - `push` - добавление значения на вершину стека (1 аргумент).
   - `0x51` - `pop` - выгрузка значения с вершины стека, с удалением этого значения со стека (1 аргумент).
   - `0x60` - `cmp` - сравнение двух чисел (из 1 аргумента вычитается 2 без изменения значений), установка флага zero (2 аргумента).
   - `0x61` - `ies` - is end string (1 аргумент). Этот оператор проверяет - является ли это слово последним в строке, 
то есть присутствует ли символ `'\0'`. Так как символы хранятся справа-налево, 
то достаточно один раз применить маску `0xFF00 0000` к слову и если получится нулевое значение, 
то это последнее слово в строке. То есть оператор применяет `and` между словом и маской `0xFF00 0000`, при этом устанавливая флаг zero.
Он является своего рода аналогом оператора `cmp`, так как он также просто устанавливает флаг без изменения каких-либо значений.
   - `0x70` - `jmp` - переход по адресу (1 аргумент).
   - `0x71` - `call` - вызов функции - добавление адреса для возврата на стек, после чего совершается переход по адресу начала функции (1 аргумент).
   - `0x72` - `ret` - выход из функции - выгрузка значения с вершины стека, после чего совершается переход по адресу (0 аргументов).
   - `0x73` - `jz` - если флаг zero = 1, то переход по адресу (1 аргумент).
   - `0x74` - `jnz` - если флаг zero = 0, то переход по адресу (1 аргумент).
   - `0x80` - `read` - чтение одного символа из буфера ввода, символ записывается в старший байт слова (1 аргумент).
   - `0x81` - `print` - запись одного символа в буфер вывода, символ считывается из младшего байта слова (1 аргумент).
9. Флаг zero - устанавливается при помощи специальных команд (`cmp` и `ies`), 
1 означает что результат вычисления этих команд равен `0x0000 0000`, в остальных случаях флаг равен 0.
10. Используется архитектура Register-to-Memory, регистр не может ссылаться на регистр.
11. Во всех операциях первым аргументом является значение с регистра, вторым - значение с памяти. 
Результат инструкции сохраняется в регистр, который указан первым аргументом 
(кроме инструкции `store` - с ней сохраняется в ячейку памяти).

## Транслятор
### Интерфейс командной строки
`translator.py <input_file> <output_instruction_file> <output_data_file> <output_mnemonic_file>`
- `<input_file>` - текстовый файл с кодом на AbobaLisp.
- `<output_instruction_file>` - бинарный файл с инструкциями.
- `<output_data_file>` - бинарный файл с данными.
- `<output_mnemonic_file>` - текстовый файл с понятным человеку отладочным выводом.<br>
Реализовано в модуле [translator](./translator.py)
### Этапы трансляции
1. Проверяется синтаксис языка AbobaLisp (закрываются ли все скобки, 
не являются ли вложенными объявления функций или переменных и так далее).
2. Проверяется семантика - объявление переменных должно идти в начале программы, после него объявление функций.
3. Последовательно создаются переменные.
4. Создаются все константы объявленные в программе.
5. Последовательно транслируются в машинный код функции 
(располагаются функции после 2-й ячейки памяти инструкций, т.к. 2 первых ячейки хранят переход на основную программу).
6. В 2 первые ячейки памяти записывается инструкция перехода на адрес ячейки после последней функции.
7. Далее последовательно транслируются в машинный код остальные выражения.
8. После трансляции всех выражений значение Heap Counter сохраняется в 3-ю ячейку памяти данных.
### Как транслируется в машинный код выражение
При помощи рекурсивного алгоритма происходит обратный обход (PostOrder) семантического дерева выражения, 
во время него создается машинный код для выражений, чьи аргументы уже были обработаны.

## Модель процессора
### Интерфейс командной строки
`machine.py <input_file> <input_instruction_file> <input_data_file>`
- `<input_file>` - текстовый файл с данными для имитации ввода в процессор.
- `<input_instruction_file>` - бинарный файл с инструкциями.
- `<input_data_file>` - бинарный файл с данными.<br>
Реализовано в модуле [machine](./machine.py)<br>
Флаги, которые используются в процессоре:
- `zero` - флаг устанавливается при помощи специальных команд (`cmp` и `ies`), 
1 означает что результат вычисления этих команд равен `0x0`, в остальных случаях флаг равен 0.
- `oea` - флаг устанавливается в 1 при помощи сигнала `output_enable_addr` в DataPath, 
сбрасывает в 0 защелкиванием Address Register. Он используется при прямой косвенной адресации,
так Address Register устанавливается в значение-указатель, которое было указано в памяти.
- `oer0`, `oer1`, `oer2`, `oer3` - флаг устанавливается в 1 при помощи сигналов
`signal_oer0`, `signal_oer1`, `signal_oer2`, `signal_oer3`, при выполнении сигнала все остальные флаги `oea` сбрасываются в 0. 
Он используется для того, чтобы было понятно из какого регистра нужно считывать данные.
### DataPath
![image](./img/data_path.png)<br>
Реализован в классе DataPath.<br>
`data_memory` - однопортовая память.<br>
Значения Stack Pointer и Heap Counter доступны в Control Unit (нужно чтобы проверять, 
то что значения со стека не заходят в кучу).
#### Селекторы
- `sel` - передается текущее машинное слово.
- `sel_instruction` - передается значение из Instruction Buffer.
#### Сигналы
- `signal_latch_stack_pointer` - защелкнуть выбранное значение в Stack Pointer. 
Если операция `push` или `call`, то (-1), если `pop` или `ret`, то (+1).
- `signal_latch_stack_buffer` - защелкнуть значение из Stack Pointer увеличенное на n в Stack Buffer. 
Используется при косвенной относительной со смещением от (SP) на память адресации на память. 
Число n является смещением относительно Stack Pointer, берется из текущего машинного слова (12 младших бит).
- `signal_latch_heap_counter` - защелкнуть значение из памяти в Heap Counter, значение берется из 3-й ячейки Data Memory.
- `signal_latch_address_reg` - защелкнуть выбранное значение в Address Register. За `arg_address` считается 
указание адресации операнда `0xA`, `0xB`, `0xD` (текущее машинное слово). 
При указании адресации операнда `0xC` загружается значение из Stack Buffer.
Если установлен флаг `oea` в 1, то загружается адрес из памяти, после чего флаг `oea` сбрасывается в 0.
- `signal_latch_second_op_buf` - защелкнуть значение из памяти данных, которое указано в Address Register, 
в Second Operand Buffer.
- `signal_output_enable_addr` - готовность к тому, чтобы значение, которое указано по адресу в Address Register, 
записалось в Address Register. Устанавливает флаг `oea` в 1, который сбрасывает в 0 защелкивание Address Register.
- `signal_output_enable` - готовность к тому, чтобы значение, которое указано по адресу в Address Register, 
записалось в Second Operand Buffer.
- `signal_latch_r0`, `signal_latch_r1`, `signal_latch_r2`, `signal_latch_r3` - 
защелкивание результата ALU, либо символа из буфера ввода в регистр, который указан после `signal_latch_`. 
Символ из буфера ввода записывается в старший байт машинного слова регистра (биты [31, 23] при нумерации справа налево).
- `signal_oer0`, `signal_oer1`, `signal_oer2`, `signal_oer3` - готовность к тому, чтобы значение из регистра, 
который указан после `out_` считалось в ALU, в память, либо в буфер вывода. 
Выставляет флаг `oer<номер выбранного регистра>` в 1, все остальные значения флагов сбрасывает в 0.
- `write_in_mem` - записать в память выбранное значение из регистра, либо из Program Counter. 
Значение записывается из того регистра, чей флаг `oer<номер регистра>` установлен в 1 (такой флаг должен быть одним).
Значение считывается из Program Counter, если операция `ret`.
- `signal_calc` - вычисление операции в ALU, первый операнд загружается из регистра, чей флаг `oer<номер регистра>` 
установлен в 1, второй операнд из Second Operand Buffer, 
инструкция подается из Instruction Buffer расположенного в Control Unit.
- `signal_input` - считать символ из буфера ввода, символ записывается в старший байт 
машинного слова регистра (биты [31, 23] при нумерации справа налево). Неявно выставляется Control Unit'ом.
- `signal_output` - записать значение из младшего байта регистра (биты [7, 0] при нумерации справа налево) в буфер вывода.

### ControlUnit
![image](./img/control_unit.png)<br>
Реализован в классе ControlUnit.<br>
Hardwired (полностью реализован на Python).<br>
`step_counter` - нужен для многотактовых инструкций, в реализации класса отсутствует, т.к. неявно задан потоком управления.
#### Селекторы
- `sel` - передается текущее машинное слово.
- `sel_next` - логический селектор, принимает значение либо true, либо false.
#### Сигналы
- `signal_latch_program_counter` - сигнал для обновления счетчика. 
Если `sel_next` установлен в true, то текущее значение Program Counter увеличенное на 1 защелкивается в Programm Counter.
Если `sel_next` установлен в true, то значение считывается либо из программной памяти, если это инструкции `jmp`, `jz`, `jnz`, `call`;
либо из памяти данных если это инструкция `ret`, для остальных инструкций бросается исключение.
- `signal_latch_instruction_buf` - защелкнуть машинное слово, которое хранит в себе номер инструкции, 
в Instruction Buffer.

## Тестирование
Реализованы [Golden тесты](./golden_test.py) программ:
- [hello](./golden/hello_aboba.yml)
- [hello_user_name](./golden/hello_user_name_aboba.yml)
- [cat](./golden/cat_aboba.yml)
- [prob1](./golden/prob1_aboba.yml)<br>
Дополнительные Golden тесты
- [print_max](./golden/print_max_aboba.yml) - выводит из переменной максимальное uint32 число
- [print_zero](./golden/print_zero_aboba.yml) - выводит из переменной ноль<br>
В Golden тестах выводится последние 200 строк логирования.
### CI при помощи Github Actions
```
name: Python CI

on:
  push:
    branches:
      - main
    paths:
      - ".github/workflows/*"
      - "**/*.py"
  pull_request:
    branches:
      - main
    paths:
      - ".github/workflows/*"
      - "**/*.py"

defaults:
  run:
    working-directory: ./

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Run tests and collect coverage
        run: |
          poetry run coverage run -m pytest .
          poetry run coverage report -m
        env:
          CI: true

  lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Check code formatting with Ruff
        run: poetry run ruff format --check .

      - name: Run Ruff linters
        run: poetry run ruff check .
```
### Пример использования и журнал работы процессора на примере `cat`:

Исходный код
```
(var r 0)
(read r 20)
(print r)
```

Входные данные
```
foo
```

Содержимое выходного файла с мнемоникой машинного кода
```
<address> - <hex_code> - <mnemonic>
000 - 7000 a002 - jmp $002
002 - 4000 a11b d002 - R2 <- load $11b | $11b -> 263
005 - 4100 a003 d002 - $r <- store R2 | $r -> $003
008 - 4100 a0ff d002 - $0ff <- store R2
00b - 4000 a100 d003 - R3 <- load $100 | $100 -> 0
00e - 2800 d003 - R3 <- srb R3
010 - 8000 d003 - R3 <- read
012 - 2800 d003 - R3 <- srb R3
014 - 8000 d003 - R3 <- read
016 - 2800 d003 - R3 <- srb R3
018 - 8000 d003 - R3 <- read
01a - 2800 d003 - R3 <- srb R3
01c - 8000 d003 - R3 <- read
01e - 4100 b0ff d003 - $(0ff) <- store R3
021 - 6100 d003 - ies R3
023 - 2100 d002 - R2 <- inc R2
025 - 4100 a0ff d002 - $0ff <- store R2
028 - 7400 a00b - jnz $00b
02a - 4000 a100 d000 - R0 <- load $100 | $100 -> 0
02d - 5000 d000 - push R0
02f - 5100 d000 - R0 <- pop
031 - 4000 a003 d002 - R2 <- load $r | $r -> $003
034 - 4100 a0ff d002 - $0ff <- store R2
037 - 4000 b0ff d003 - R3 <- load $(0ff)
03a - 8100 d003 - print R3
03c - 2800 d003 - R3 <- srb R3
03e - 8100 d003 - print R3
040 - 2800 d003 - R3 <- srb R3
042 - 8100 d003 - print R3
044 - 2800 d003 - R3 <- srb R3
046 - 8100 d003 - print R3
048 - 2800 d003 - R3 <- srb R3
04a - 4000 b0ff d003 - R3 <- load $(0ff)
04d - 6100 d003 - ies R3
04f - 2100 d002 - R2 <- inc R2
051 - 4100 a0ff d002 - $0ff <- store R2
054 - 7400 a037 - jnz $037
056 - 4000 a100 d000 - R0 <- load $100 | $100 -> 0
059 - 5000 d000 - push R0
05b - 5100 d000 - R0 <- pop
05d - 1000 - halt
```

Журнал работы процессора
```
DEBUG:root:0 | TICK: 0 PC: 000 IB 0000 (DataPath - AR: 000 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000000 R3: 00000000 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:1 | TICK: 3 PC: 002 IB 7000 (DataPath - AR: 000 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000000 R3: 00000000 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:2 | TICK: 12 PC: 005 IB 4000 (DataPath - AR: 11b SP: fff SB: 000 HC: 11c SOB: 00000107 (ALU - result: 00000107 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:3 | TICK: 19 PC: 008 IB 4100 (DataPath - AR: 003 SP: fff SB: 000 HC: 11c SOB: 00000107 (ALU - result: 00000107 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:4 | TICK: 26 PC: 00b IB 4100 (DataPath - AR: 0ff SP: fff SB: 000 HC: 11c SOB: 00000107 (ALU - result: 00000107 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:5 | TICK: 35 PC: 00e IB 4000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:6 | TICK: 41 PC: 010 IB 2800 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:input: 'f'
DEBUG:root:7 | TICK: 46 PC: 012 IB 8000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 66000000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:8 | TICK: 52 PC: 014 IB 2800 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00660000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00660000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:input: 'o'
DEBUG:root:9 | TICK: 57 PC: 016 IB 8000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00660000 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 6f660000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:10 | TICK: 63 PC: 018 IB 2800 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 006f6600 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6600 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:input: 'o'
DEBUG:root:11 | TICK: 68 PC: 01a IB 8000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 006f6600 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 6f6f6600 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:12 | TICK: 74 PC: 01c IB 2800 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 006f6f66 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
WARNING:root:Input buffer is empty!
DEBUG:root:13 | TICK: 77 PC: 01d IB 8000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 006f6f66 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:14 | TICK: 78 PC: 01e IB 8000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 006f6f66 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:15 | TICK: 87 PC: 021 IB 4100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 006f6f66 zero: False) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:16 | TICK: 92 PC: 023 IB 6100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:17 | TICK: 98 PC: 025 IB 2100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000108 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:18 | TICK: 105 PC: 028 IB 4100 (DataPath - AR: 0ff SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000108 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:19 | TICK: 108 PC: 02a IB 7400 (DataPath - AR: 0ff SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000108 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:20 | TICK: 117 PC: 02d IB 4000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:21 | TICK: 123 PC: 02f IB 5000 (DataPath - AR: ffe SP: ffe SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:22 | TICK: 132 PC: 031 IB 5100 (DataPath - AR: ffe SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:23 | TICK: 141 PC: 034 IB 4000 (DataPath - AR: 003 SP: fff SB: 000 HC: 11c SOB: 00000107 (ALU - result: 00000107 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:24 | TICK: 148 PC: 037 IB 4100 (DataPath - AR: 0ff SP: fff SB: 000 HC: 11c SOB: 00000107 (ALU - result: 00000107 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:25 | TICK: 159 PC: 03a IB 4000 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 006f6f66 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:output:  << f
DEBUG:root:26 | TICK: 164 PC: 03c IB 8100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 006f6f66 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:27 | TICK: 170 PC: 03e IB 2800 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00006f6f zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00006f6f oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:output: f << o
DEBUG:root:28 | TICK: 175 PC: 040 IB 8100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00006f6f zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00006f6f oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:29 | TICK: 181 PC: 042 IB 2800 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 0000006f zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 0000006f oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:output: fo << o
DEBUG:root:30 | TICK: 186 PC: 044 IB 8100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 0000006f zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 0000006f oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:31 | TICK: 192 PC: 046 IB 2800 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:zero value skipped for output: foo << \0
DEBUG:root:32 | TICK: 197 PC: 048 IB 8100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:33 | TICK: 203 PC: 04a IB 2800 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 00000000 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:34 | TICK: 214 PC: 04d IB 4000 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 006f6f66 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:35 | TICK: 219 PC: 04f IB 6100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000107 R3: 006f6f66 oer0: False oer1: False oer2: False oer3: True))
DEBUG:root:36 | TICK: 225 PC: 051 IB 2100 (DataPath - AR: 107 SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000108 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:37 | TICK: 232 PC: 054 IB 4100 (DataPath - AR: 0ff SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000108 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:38 | TICK: 235 PC: 056 IB 7400 (DataPath - AR: 0ff SP: fff SB: 000 HC: 11c SOB: 006f6f66 (ALU - result: 00000108 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:39 | TICK: 244 PC: 059 IB 4000 (DataPath - AR: 100 SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: False oer1: False oer2: True oer3: False))
DEBUG:root:40 | TICK: 250 PC: 05b IB 5000 (DataPath - AR: ffe SP: ffe SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: True oer1: False oer2: False oer3: False))
DEBUG:root:41 | TICK: 259 PC: 05d IB 5100 (DataPath - AR: ffe SP: fff SB: 000 HC: 11c SOB: 00000000 (ALU - result: 00000000 zero: True) (Registers - R0: 00000000 R1: 00000000 R2: 00000108 R3: 006f6f66 oer0: True oer1: False oer2: False oer3: False))
INFO:root:output_buffer: 'foo'
```

Результат работы
```
foo
code_byte:  188 code_instr:  94 instr_counter:  41 ticks:  259
```

### Пример проверки исходного кода:
```
Run poetry run coverage run -m pytest .
============================= test session starts ==============================
platform linux -- Python 3.11.8, pytest-8.0.2, pluggy-1.4.0
rootdir: /home/runner/work/ac-third-lab/ac-third-lab
configfile: pyproject.toml
plugins: golden-0.2.2
collected 6 items

golden_test.py ......                                                    [100%]

============================== 6 passed in 8.54s ===============================
Name               Stmts   Miss  Cover   Missing
------------------------------------------------
checker.py            60      0   100%
golden_test.py        30      0   100%
isa.py                98      7    93%   69, 110, 148-153
machine.py           587     27    95%   68, 148, 163-164, 219-220, 232-233, 257-258, 438-439, 447-450, 461-462, 477-478, 653-654, 719, 758-761
memory_config.py      17      0   100%
mnemonic.py          156      9    94%   140, 156, 168, 175-176, 197, 202, 211-212
translator.py        620     81    87%   116-120, 138-163, 185, 335-336, 343-347, 359, 399, 557-558, 567-575, 586-593, 606-607, 611, 624, 631-633, 649-655, 660, 673-682, 686, 697-701, 706-708, 782-783, 853-856
------------------------------------------------
TOTAL               1568    124    92%
```

```text
| Стрельбицкий Илья Павлович | hello            | 1   | 94        | 47          | 62     | 391    | lisp | cisc | harv | hw | instr | binary | stream | mem | cstr | prob1 | [4]char |
| Стрельбицкий Илья Павлович | cat              | 3   | 188       | 94          | 154    | 938    | lisp | cisc | harv | hw | instr | binary | stream | mem | cstr | prob1 | [4]char |
| Стрельбицкий Илья Павлович | hello__user_name | 6   | 452       | 226         | 199    | 1242   | lisp | cisc | harv | hw | instr | binary | stream | mem | cstr | prob1 | [4]char |
| Стрельбицкий Илья Павлович | prob1            | 5   | 790       | 395         | 51497  | 401841 | lisp | cisc | harv | hw | instr | binary | stream | mem | cstr | prob1 | [4]char |
```